<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test</title>
      <link href="/2022/03/06/test/"/>
      <url>/2022/03/06/test/</url>
      
        <content type="html"><![CDATA[<p>This is the passage written by my laptop.</p><p>This is just a test.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>R2S家庭组网实操</title>
      <link href="/2022/02/26/R2S_build/"/>
      <url>/2022/02/26/R2S_build/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文授权转载自<a href="https://www.bytedance.fit/?p=1051">R2S家庭组网实操 – Orange Tien</a>，作者：Orange Tien，在此基础上略加修改，<del>并不会定期更新</del>。</p><p>本文主要介绍R2S的基本使用方法，目前本人（Tony）也在原作者（Orange Tien）的怂恿下在两个地方分别搭建了两个R2S，看起来很简单，其实不是一帆风顺；因此也会把实际组网中遇到的问题列到最后供大家参考。</p><h2 id="确定所需物理设备"><a href="#确定所需物理设备" class="headerlink" title="确定所需物理设备"></a>确定所需物理设备</h2><ul><li>一台R2S软路由以及它的电源线</li><li>两根用不着太长的网线一张TF卡（作为R2S的系统盘）以及一个读写TF卡的读卡器</li><li>一台可以插网线的电脑</li><li>交换机（可选）</li><li>插排（某些时候插座不够用）</li></ul><h2 id="烧录OpenWrt系统"><a href="#烧录OpenWrt系统" class="headerlink" title="烧录OpenWrt系统"></a>烧录OpenWrt系统</h2><p>烧录软件：<a href="https://www.balena.io/etcher/">BalenaEtcher</a></p><p>软路由系统：</p><p><a href="https://bigdongdong.cowtransfer.com/s/a3420546d30343">OpenWrt-R2S-dongdong</a></p><p><a href="https://bigdongdong.cowtransfer.com/s/9a349ee597aa4f">OpenWrt-R2S-esir</a></p><p>第一个链接比较新，界面比较好看一些，推荐选择这个下载；第二个系统是eSir大人写的2020版本，已经很旧了；<del>奈何暂时没找到别的系统</del>，如果自行找到更好的系统也可以不用这俩链接。注意系统是要支持Arm架构的，因为Openwrt不是x86架构下的产物。</p><h2 id="开始烧录系统至TF卡"><a href="#开始烧录系统至TF卡" class="headerlink" title="开始烧录系统至TF卡"></a>开始烧录系统至TF卡</h2><p>打开BalenaEtcher，选择Flash from file，然后将OpenWrt系统烧录到TF卡中即可。</p><p><img src="/2022/02/26/R2S_build/image-1.png" alt="img" loading="lazy"></p><p>注意：选择文件时只选择镜像文件，不要把那些七七八八的文档说明也选进去。选择<code>.gz</code>(<code>.img</code>)文件来烧录即可，烧录完成后直接拔掉读卡器；系统会提示格式化，此时千万<strong>不要</strong>格式化！！！（<del>否则，就重来一遍吧</del>）</p><h2 id="登入R2S后台"><a href="#登入R2S后台" class="headerlink" title="登入R2S后台"></a>登入R2S后台</h2><p>把烧录好固件的TF卡插入R2S，然后给它插上电源，WAN口可以不接，将R2S的LAN口连接电脑的网口，根据所刷入的固件（软路由系统）的不同来决定后台地址，一般来说，软路由后台是<code>192.168.X.1</code> ，本文的系统后台是<code>192.168.22.1</code>，所以说我们在电脑浏览器内输入<code>192.168.5.1</code>(<code>192.168.22.1</code>)以进入后台。后台账号是root，默认密码基本都是password（若下载本文的系统，密码则为空），具体操作链接里面写的很清楚。</p><h2 id="拨号或者DHCP客户端"><a href="#拨号或者DHCP客户端" class="headerlink" title="拨号或者DHCP客户端"></a>拨号或者DHCP客户端</h2><h3 id="光猫拨号"><a href="#光猫拨号" class="headerlink" title="光猫拨号"></a>光猫拨号</h3><p>如果你家里的组网方式是通过光猫拨号（通常都是光猫拨号），那么设置方法如下：</p><p>选择 网络-接口， 然后选择 修改WAN口设置</p><p><img src="/2022/02/26/R2S_build/image-2-1024x507.png" alt="img" loading="lazy"></p><p>将WAN口设置成DHCP客户端，然后保存应用即可，此外无须做其他任何设置。</p><p><img src="/2022/02/26/R2S_build/image-3-1024x485.png" alt="img" loading="lazy"></p><h3 id="R2S拨号"><a href="#R2S拨号" class="headerlink" title="R2S拨号"></a>R2S拨号</h3><p>如果你的光猫是桥接，那么就由路由器来拨号（通常来说，哪个网络设备配置更好，就誰来拨号，由于R2S的稳定性远不如光猫，所以这里选择光猫拨号更好），设置方法如下：</p><p><img src="/2022/02/26/R2S_build/image-5.png" alt="img" loading="lazy"></p><p>同样，选择修改WAN口，协议设置成PPPoE, PAP/CHAP，账号密码就是光猫的账号密码。比如电信宽带就是以<code>@163.gd</code>结尾的，密码如果忘记的话直接拨打10000（10086）重置就好，省时省力。</p><p><img src="/2022/02/26/R2S_build/image-2-1024x507.png" alt="img" loading="lazy"></p><p>接下来，需要用超级管理员账号登陆到光猫的IP中（<code>192.168.1.1</code>）,各大运营商的超级管理员账号和密码可以自行搜索。选择 网络-协议，然后设置成DHCP客户端。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>用什么拨号，什么就选择PPPoE，然后其它设备就都设置成DHCP。</p><p>用光猫拨号，光猫的设置里面就选择PPPoE，软路由以及其它路由器就选择DHCP客户端；</p><p>用R2S拨号，光猫和其它路由设备的设置里面就选择DHCP客户端，软路由选择PPPoE。</p><h2 id="各设备接入网络"><a href="#各设备接入网络" class="headerlink" title="各设备接入网络"></a>各设备接入网络</h2><p>将软路由的WAN口与光猫的千兆口相连，然后断开软路由的LAN口与电脑网口的连接，此时软路由的LAN口根据各人组网要求的不同选择接不同的设备，可以接交换机，也可以接一台路由器（路由器设置为有线中继模式，也就是无线AP模式）</p><p>如果家中设备比较多，或者很多屋子都需要连网线的话，可以买一个最便宜的千兆交换机放到弱电箱中，然后吧R2S接到交换机与光猫中间，这样就可以实现整个局域网都接入到软路由中来。（我来草草的画个图）</p><p><img src="/2022/02/26/R2S_build/image-20220305212846426.png" alt="image-20220305212846426" loading="lazy"></p><h2 id="利用插件设置科学上网"><a href="#利用插件设置科学上网" class="headerlink" title="利用插件设置科学上网"></a>利用插件设置科学上网</h2><p>根据前面的步骤，如果你的设备能够正常访问网络了，就可以开始探索OpenWrt的各类插件了。关于科学上网，常见的插件有PassWall, ShadowScoksR++, OpenClash，由于OpenClash具备强大的分流策略机制（根据你访问的域名或者IP的不同决定走不同的节点），我们在此以OpenCalsh为例设置科学上网</p><p><img src="/2022/02/26/R2S_build/image-7.png" alt="img" loading="lazy"></p><p>首先，在服务菜单中找到OpenClash，然后选择配置文件订阅，选择添加配置文件</p><p><img src="/2022/02/26/R2S_build/image-8.png" alt="img" loading="lazy"></p><p>配置文件名随便写，用途是给用户自己区分的，订阅地址填上机场给你的订阅地址，其余地方无需设置，直接应用并保存即可。然后回到OpenClash主页，配置文件区域发送了变化。</p><p><img src="/2022/02/26/R2S_build/image-9-1024x194.png" alt="img" loading="lazy"></p><p>最后点击左下角的启动按钮，等待服务器上线运行即可。</p><p><img src="/2022/02/26/R2S_build/image-10.png" alt="img" loading="lazy"></p><p>如果你设置后无法正常科学上网，原因是有很多的，需要你自己慢慢排查。</p><h2 id="更多（原作者的话）"><a href="#更多（原作者的话）" class="headerlink" title="更多（原作者的话）"></a>更多（原作者的话）</h2><p><a href="https://wiki.friendlyarm.com/wiki/index.php/NanoPi_R2S/zh">NanoPi R2S WIKI</a></p><p>上面的链接是R2S的WIKI书，上面详细记录了R2S的配置以及实际测速情况，也有如何编译系统等教程。</p><p>个人使用R2S两年，从大一到大三都在用这个，感觉就是到千兆不太行，500M是瓶颈了，然后连久了没那么稳定，官网手册上宣传它是又稳定又能达到千兆的，这个听听就好，R2S本来是适合入门的，但是现在价格炒的太高了，没这个必要去买它，目前有很多更具有性价比的软路由可供选择。</p><p>此外向大家推荐软路由界的大佬: <a href="https://youtube.com/c/jackstone">JackStone的Youtube主页</a> ，人称老白，做了很多小主机的视频，如果想选购更具性价比的设备，可以看他的合集，比如2021软路由选购建议这些。</p><h2 id="组网时遇到过的问题（我的话）"><a href="#组网时遇到过的问题（我的话）" class="headerlink" title="组网时遇到过的问题（我的话）"></a>组网时遇到过的问题（我的话）</h2><ol><li>组网的过程中可能出现无法自动分配IP地址的问题，比如说小米的路由器默认会分配<code>192.168.31.XXX</code>；如果你会手动配置的话可以试试，不过最简单的办法就是等，去洗个澡回来就好了。如果还没好，那么可以考虑RESET一下路由器。</li><li>OpenClash插件在首次启动的时候，可能会启动失败，他会提示需要你选择编译架构，按照他的提示，选择Arm-v8架构即可。</li><li>网线通常插上马上就会亮灯，5s左右就能ping通，不过不要太相信科学。<del>我有一次ping了10多分钟。</del>真的，不通的话不一定是没插紧，也不一定是插错了，<strong>很有可能是因为你没给我微信或者支付宝赞赏</strong>。</li><li>R2S是很基础的一款软路由，稳定性可能不会太好，不过最有可能导致网络不稳定的还是机场的选择，如果选择廉价机场的话，要做好不知道什么时候突然断网10分钟的准备。</li><li>计算机网络这门学科是玄学的一个分支。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R2S </tag>
            
            <tag> Computer Network </tag>
            
            <tag> 软路由 </tag>
            
            <tag> 科学上网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链式二叉树简介</title>
      <link href="/2022/02/25/binary_tree_1/"/>
      <url>/2022/02/25/binary_tree_1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>人为什么难做选择？</p></blockquote><p><strong>选择意味着放弃</strong></p><p>你选择一方，也就意味着放弃了另一方。摆在你面前的选择项越接近，你的选择就会越困难，因为放弃其中任何一个选择项都不容易。如果摆在你面前的选择项对比明显，那么选择起来就会轻松许多，大家几乎都会毫不犹豫的选择“好”的选择项，放弃掉“差”的选择项。</p><p><strong>选择永远都不是完美的</strong></p><p>选择永远都不可能十全十美，只可能满足尽量多的侧重点。选择的时候想满足越多的侧重点，可能就会越难做出选择。所以在选择上不要过于追求完美。</p><p>警惕<strong>逃避性选择</strong>——不知道自己要去哪儿，还要选择离开。</p><p>有一种选择是对现状不满，想逃离这种现状，但是却不知道去哪里。举个例子，可能目前的公司有各种问题，比如开发流程不规范等，如果因为这些问题离开，可能就会从一个坑跳到另外一个更大的坑。当决定离开的时候，一定是自己有明确的目标，很清楚自己想要什么。</p><hr><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><p>二叉树要么为空，要么由根节点（root），左子树（left subtree）和右子树（right subtree）组成，而且左子树和右子树分别是一棵二叉树。</p><hr><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><ul><li>先序遍历$PreOrder(T)=Root(T)+PreOrder(left subT)+PreOrder(right subT)$</li><li>中序遍历$InOrder(T)=InOrder(left subT)+Root(T)+InOrder(right subT)$</li><li>后序遍历$PostOrder(T)=PostOrder(left subT)+PostOrder(Right subT)+Root(T)$</li></ul><p><img src="/2022/02/25/binary_tree_1/image.png" alt="img" loading="lazy"></p><hr><pre class="language-none"><code class="language-none">struct Bitree &#x2F;&#x2F;definition&#123;    int data;    Bitree Lchild;    Bitree Rchild;&#125;;</code></pre><h2 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h2><ol><li>递归实现</li></ol><pre class="language-none"><code class="language-none">void PreOrderTraverse(BiTree tree)&#123;    if (tree &#x3D;&#x3D; NULL)        return;    cout &lt;&lt; tree-&gt;data;    PreOrderTraverse(tree-&gt;lchild);    PreOrderTraverse(tree-&gt;rchild);&#125;</code></pre><ol><li>迭代实现</li></ol><pre class="language-none"><code class="language-none">void PreOrder(BiTree Root)&#123;    stack &lt;BiTree&gt; s;    if (root) &#x2F;&#x2F;如果根节点不为空        s.push(root); &#x2F;&#x2F;则令根节点入栈    while (!s.empty()) &#x2F;&#x2F;在栈变空之前反复循环    &#123;         root &#x3D; s.pop();         cout &lt;&lt; root-&gt;data; &#x2F;&#x2F;弹出并访问当前节点        &#x2F;&#x2F;下面左右孩子的顺序不能颠倒        &#x2F;&#x2F;必须先让右孩子先入栈，再让左孩子入栈。        if (root-&gt;RChild)            s.push(root-&gt;RChild); &#x2F;&#x2F;右孩子先入后出        if (root-&gt;LChild)            s.push(root-&gt;LChild); &#x2F;&#x2F;左孩子后入先出    &#125;&#125;</code></pre><p>我们通过一个实例来了解一下该迭代版本是如何工作的 :</p><p><img src="/2022/02/25/binary_tree_1/v2-0ccba83c7b3dbf7b89964c04021025d9_720w.jpg" alt="img" loading="lazy"></p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><ol><li>递归实现</li></ol><pre class="language-none"><code class="language-none">void InOrderTraverse(BiTree tree)&#123;    if (!tree)        return;    InOrderTraverse(tree-&gt;lchild);    cout &lt;&lt; tree-&gt;data;    IndOrderTraverse(tree-&gt;rchild);&#125;</code></pre><ol><li>迭代实现</li></ol><pre class="language-none"><code class="language-none">void InOrderTraverse(BiTree root)&#123;   Stack&lt;BiTree&gt; S; &#x2F;&#x2F;辅助栈   while (true)      if (root)       &#123;         S.push (root); &#x2F;&#x2F;根节点进栈         root &#x3D; root-&gt;LChild; &#x2F;&#x2F;深入遍历左子树      &#125;       else if (!S.empty())       &#123;         root &#x3D; S.pop(); &#x2F;&#x2F;尚未访问的最低祖先节点退栈         cout &lt;&lt; root-&gt;data; &#x2F;&#x2F;访问该祖先节点         root &#x3D; root-&gt;RChild; &#x2F;&#x2F;遍历祖先的右子树      &#125;       else         break; &#x2F;&#x2F;遍历完成&#125;</code></pre><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><ol><li>递归实现</li></ol><pre class="language-none"><code class="language-none">void PostOrderTraverse(BiTree tree)&#123;    if (!tree)        return;    InOrderTraverse(tree-&gt;Lchild);    IndOrderTraverse(tree-&gt;Rchild);    cout &lt;&lt; tree-&gt;data;&#125;</code></pre><ol><li>迭代实现</li></ol><pre class="language-none"><code class="language-none">#define A !cur-&gt;Lchild &amp;&amp; !cur-&gt;Rchild&#x2F;&#x2F;如果P不存在左孩子和右孩子，则可以直接访问它；#define B pre&#x3D;&#x3D;cur-&gt;Lchild || pre&#x3D;&#x3D;cur-&gt;Rchild&#x2F;&#x2F;P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了;void PostOrder(BiTree Root)&#123;    if (!Root)        return;    stack &lt;BiTree&gt; s;&#x2F;&#x2F;辅助栈    BiTree cur&#x3D;Root,pre&#x3D;NULL;    s.push(Root);&#x2F;&#x2F;根节点进栈    while (!s.empty())    &#123;        cur&#x3D;s.top();        if (A || B)        &#123;            cout &lt;&lt; cur-&gt;data;            s.pop();            pre&#x3D;cur;        &#125;        else        &#123;            if (cur-&gt;Rchild)                s.push(cur-&gt;Rchild);            if (cur-&gt;Lchild)                s.push(cur-&gt;Lchild);        &#125;    &#125;&#125;</code></pre><hr><p>下一篇文章：<a href="https://tonylsx611.github.io/2022/02/24/binary_tree_2/">数组与链式二叉树之间的转换 | Tony (tonylsx611.github.io)</a></p><script type="math/tex; mode=display">END</script>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Binary-tree </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组与链式二叉树的转换</title>
      <link href="/2022/02/24/binary_tree_2/"/>
      <url>/2022/02/24/binary_tree_2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对二叉树不是很了解的同学可以先看一下我之前的文章：</p><p><a href="https://tonylsx611.github.io/2022/02/25/binary_tree_1/">链式二叉树简介</a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在了解二叉树的基本原理后，我们尝试将一个数组转化成链表形式的二叉树，之后将二叉树以中序遍历打印出来。整个的过程即==数组——链表——数组==。</p><p>幸运的是，正好在leetcode中有着一道非常相似的题，所以我就直接拿来使用了，链接如下：</p><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历 – 力扣（LeetCode） (leetcode-cn.com)</a></p><p>我们稍加修改，首先声明一个int类型的数组，然后把它放入链表二叉树中，如图所示：</p><p><img src="/2022/02/24/binary_tree_2/image.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">int arr[7] &#x3D; &#123; 1, 2, 3, 4, 5, NULL, 6 &#125;;</code></pre><p>之后的任务就是将数组转化为链表形式，链表的定义如下：</p><pre class="language-none"><code class="language-none">struct TreeNode &#123;    int val;    TreeNode* left;    TreeNode* right;    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) &#123;&#125;&#125;;</code></pre><p>转化为链表过后，剩下的事情就很容易了，无非就是前中后序的遍历，我们在<a href="https://tonylsx611.github.io/2022/02/25/binary_tree_1/">上一个blog</a>中已经有详细的介绍，这里更希望大家掌握迭代的算法，而非递归；因为递归在电脑的底层逻辑中，依然是维护一个栈。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>那么全部的代码如下，不做过多解释，有疑问可以在留言板留言。</p><pre class="language-none"><code class="language-none">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;struct TreeNode &#123;...&#125;;class Solution &#123;public:    int arr[7] &#x3D; &#123; 1, 2, 3, 4, 5, NULL, 6 &#125;;    void inorder(TreeNode* root, vector&lt;int&gt;&amp; res)&#x2F;&#x2F;中序遍历    &#123;        if (root &#x3D;&#x3D; nullptr)            return;        inorder(root-&gt;left, res);        res.push_back(root-&gt;val);        inorder(root-&gt;right, res);    &#125;    vector&lt;int&gt; inorderTraversal(TreeNode* root)&#x2F;&#x2F;递归法    &#123;        vector&lt;int&gt; ans;        inorder(root, ans);        return ans;    &#125;    vector&lt;int&gt; inorderTraversal(TreeNode* root)&#x2F;&#x2F;迭代法    &#123;        vector&lt;int&gt; ans;        stack&lt;TreeNode*&gt; stk;                   while (1)        &#123;            if (root !&#x3D; nullptr)            &#123;                stk.push(root);                root &#x3D; root-&gt;left;            &#125;            else if (!stk.empty())            &#123;                root &#x3D; stk.top();                stk.pop();                ans.push_back(root-&gt;val);                root &#x3D; root-&gt;right;            &#125;            else                return ans;        &#125;            &#125;    TreeNode* addtree(TreeNode* tree, int arr[], int i)&#x2F;&#x2F;数组转链表    &#123;        if (arr[i] &#x3D;&#x3D; 0)            return NULL;        if (i &lt; 7)&#x2F;&#x2F;arr.length()        &#123;            TreeNode* tree &#x3D; new TreeNode();                        tree-&gt;val &#x3D; arr[i];            tree-&gt;left &#x3D; addtree(tree, arr, i + i + 1);            tree-&gt;right &#x3D; addtree(tree, arr, i + i + 2);            return tree;        &#125;        return NULL;    &#125;&#125;;int main()&#123;    Solution sol;    TreeNode* tree &#x3D; NULL;    tree&#x3D; sol.addtree(tree, sol.arr, 0);    sol.inorderTraversal(tree);    for(int i&#x3D; 0; i&lt; sol.inorderTraversal(tree).size(); i++)        cout &lt;&lt; sol.inorderTraversal(tree)[i]&lt;&lt;&quot; &quot;;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Binary-tree </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 网站搭建指南</title>
      <link href="/2022/02/24/Hexo_creation/"/>
      <url>/2022/02/24/Hexo_creation/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-网站搭建指南"><a href="#Hexo-网站搭建指南" class="headerlink" title="Hexo 网站搭建指南"></a>Hexo 网站搭建指南</h1><p>Welcome to <a href="https://hexo.io/">Hexo</a>! </p><p>This is a Guideline of building your own hexo, which is written in English, but easy to understand!</p><h2 id="搭建前的准备"><a href="#搭建前的准备" class="headerlink" title="搭建前的准备"></a>搭建前的准备</h2><h3 id="Git-Installation"><a href="#Git-Installation" class="headerlink" title="Git Installation"></a>Git Installation</h3><ul><li>Linux/Mac:</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">git</span></code></pre><ul><li>Windows:</li></ul><p>Official link: <a href="https://gitforwindows.org/">Download git</a></p><ul><li>Check whether installed or not:</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> --version</code></pre><h3 id="Nodejs-Installation"><a href="#Nodejs-Installation" class="headerlink" title="Nodejs Installation"></a>Nodejs Installation</h3><ul><li>Linux/Mac:</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> nodejs<span class="token function">sudo</span> aot <span class="token function">install</span> <span class="token function">npm</span></code></pre><ul><li>Windows:</li></ul><p>Official link: <a href="https://nodejs.org/en/download/">nodejs</a> (Suggest you to choose LTS version)</p><ul><li>Check whether installed or not:</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">node</span> -v<span class="token function">npm</span> -v</code></pre><h3 id="Hexo-Installation"><a href="#Hexo-Installation" class="headerlink" title="Hexo Installation"></a>Hexo Installation</h3><ul><li>Linux/Mac:</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli</code></pre><ul><li>Windows:</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli</code></pre><ul><li>Check whether installed or not:</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">hexo -v</code></pre><h2 id="部署本地Hexo网站"><a href="#部署本地Hexo网站" class="headerlink" title="部署本地Hexo网站"></a>部署本地Hexo网站</h2><p>​        First you need to <strong>choose or create a folder</strong> to storage the local hexo website. For instance, in <code>C:/Software/My_Hexo</code>.</p><p>​        Then right click the folder, click <code>open in Windows terminal</code>; or just use command line to get into that folder.</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> hexo init Mybolg<span class="token function">ls</span> Myblog<span class="token function">sudo</span> <span class="token function">npm</span> <span class="token function">install</span></code></pre><p>​        *Note that you can replace <code>Mybolg</code> into any word you like.</p><p>​        Now you can see some files inside the folder, but only three folders you need to concerntrated.</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>==source==：你的文章和素材放在这里</li><li>==themes==：字面意思</li><li>==_config.yml==: 博客的配置文件</li></ul><h2 id="使用Github托管网页"><a href="#使用Github托管网页" class="headerlink" title="使用Github托管网页"></a>使用Github托管网页</h2><h3 id="Create-a-new-repository-on-Github"><a href="#Create-a-new-repository-on-Github" class="headerlink" title="Create a new repository on Github"></a>Create a new repository on Github</h3><p>​        Firstly, you need to have a github account…</p><p>​        Then, create a <strong>new repository</strong> on github and named <code>yourusername.github.io</code>, note that you <strong>must</strong> named like this (<code>yourusername</code> is your user name), otherwise the deployment cannot be reconigzed. </p><h3 id="Add-SSH-key-to-Github"><a href="#Add-SSH-key-to-Github" class="headerlink" title="Add SSH key to Github"></a>Add SSH key to Github</h3><p>​        Back to the terminal, generate the SSH and add it into github so that github can know whether the your computer are visiting the corresponding account.</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> cofig --global user.name <span class="token string">"yourusername"</span><span class="token function">git</span> cofig --global user.email <span class="token string">"youremail"</span>ssh-keygen -t rsa -C <span class="token string">"youremail"</span></code></pre><p>​        The computer then will tell you the path of <code>.ssh</code>, find it on your computer, and open it via notepad.</p><p>​        To say it simpler, ssh is just the ID of your computer, github recogized your computer via this ID. <code>id_rsa</code> is your private key that you cannot show it to others, while <code>id_rsa.pub</code> is the public key, you can copy the info to github.</p><p>​        <code>Github -&gt; settings -&gt; personal settings -&gt; SSH and PGP keys -&gt; New SSH key</code></p><p>​        You can verify whether add the SSH key successfully via your terminal:</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> -T git@github.com</code></pre><h3 id="Deploy-hexo-to-Github"><a href="#Deploy-hexo-to-Github" class="headerlink" title="Deploy hexo to Github"></a>Deploy hexo to Github</h3><p>​        Open your folder, remember the three folders that I let you to conceretrate? Now it truns into <code>_config.yml</code> file, open it and add something in the end:</p><pre class="language-bash" data-language="bash"><code class="language-bash">deploy:  type: <span class="token function">git</span>  repo: https://github.com/yourusername/yourusername.github.io.git  branch: master</code></pre><p>​        <em>Notice the format must be totally same with me, pay attention to the <em>*blanks</em></em>.</p><p>​        Before deployment, you need to install the <code>deploy-git</code> in your computer so that you can deploy your own hexo into github.</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git --save</code></pre><p>​        Finally, deploy your website via the following commands, and you can visit your bolg via <code>http://yourusername.github.io</code>.</p><pre class="language-bash" data-language="bash"><code class="language-bash">hexo cleanhexo deployhexo generate</code></pre><h2 id="上传你的第一个文章"><a href="#上传你的第一个文章" class="headerlink" title="上传你的第一个文章"></a>上传你的第一个文章</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="language-bash" data-language="bash"><code class="language-bash">hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="language-bash" data-language="bash"><code class="language-bash">hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="language-bash" data-language="bash"><code class="language-bash">hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="language-bash" data-language="bash"><code class="language-bash">hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="Advanced-Settings"><a href="#Advanced-Settings" class="headerlink" title="Advanced Settings"></a>Advanced Settings</h3><p>Create a bat format file (e.g. <code>start.bat</code>) in the root folder of your blog.</p><pre class="language-bash" data-language="bash"><code class="language-bash">hexo clean <span class="token operator">&amp;</span> hexo d <span class="token operator">&amp;</span> hexo g <span class="token operator">&amp;</span> hexo spause</code></pre><p>Then every time you uploaded a file or change any settings, you can just double click the .bat file to update your blog, which is very convenience.</p><hr><p>注：本文部分内容引用自<a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">hexo史上最全搭建教程_Fangzh的技术博客</a>， 如有侵权，请联系我。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo文章发布指南</title>
      <link href="/2022/02/20/Hexo_article/"/>
      <url>/2022/02/20/Hexo_article/</url>
      
        <content type="html"><![CDATA[<h1 id="文章标题H1"><a href="#文章标题H1" class="headerlink" title="文章标题H1"></a>文章标题H1</h1><p>在md下直接使用 # 进行新建标题，左侧菜单栏会自动生成H1-H6的标题，very nice!</p><ul><li>标题样式：</li></ul><h2 id="H2"><a href="#H2" class="headerlink" title="H2"></a>H2</h2><h3 id="H3"><a href="#H3" class="headerlink" title="H3"></a>H3</h3><h4 id="H4"><a href="#H4" class="headerlink" title="H4"></a>H4</h4><h5 id="H5"><a href="#H5" class="headerlink" title="H5"></a>H5</h5><h6 id="H6"><a href="#H6" class="headerlink" title="H6"></a>H6</h6><h1 id="头部字段"><a href="#头部字段" class="headerlink" title="头部字段"></a>头部字段</h1><p>在文章的第一行使用三个<code>-</code>（就是分割线）来创建头部字段。</p><ul><li>格式如下：</li></ul><pre class="language-none"><code class="language-none">title: Hexo文章发布指南date: 2077-02-20 00:34:49author: Tonycategories:- Hexo搭建tags: - tag1- tag2katex: true</code></pre><h1 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h1><p>行内公式使用$将数学公式括起来就好，行间公式使用两个$$，这跟md的格式是一样的。</p><p>需要注意的是，如果文章中需要使用数学公式，最好在头部字段前添加<code>katex: true</code>的字样。</p><ul><li>数学公式样例：</li></ul><p>我是行内公式：$x=x^{45}+3$，我还可以接着写。。。</p><script type="math/tex; mode=display">x_1=x_3+2\times x^6\\\alpha：我是行间公式\\\left[\begin{matrix}1 & 2 & 3\\4 & 5 & 6\\7 & 8 & 9\\\end{matrix}\right]</script><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>只需要将图片拖入md文档中即可，md会自动创建一个与文件名相同的文件夹以储存所有的图片素材，并会自动将图片复制到该文件夹中，因此所有的图片只需要输入相对路径即可。</p><p>比如，本文章的名字为test，那么只需要这样写：<code>![IMG_1479](test/IMG_1479.jpg)</code></p><p>注：Hexo支持GIF格式的图片哦！</p><p><img src="/2022/02/20/Hexo_article/IMG_1479.jpg" alt="IMG_1479" loading="lazy"></p><p><img src="/2022/02/20/Hexo_article/2d6f869662e83398f06070e2a14f838.jpg" alt="2d6f869662e83398f06070e2a14f838" loading="lazy"></p><p><img src="/2022/02/20/Hexo_article/traffic-light.gif" alt="traffic-light" loading="lazy"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>没啥可说的。。。</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;int main()&#123;int a,b,c;cin&gt;&gt;a&gt;&gt;c;for(int i&#x3D;0;i&lt;a;i++)cout&lt;&lt;c*a&lt;&lt;endl;return 0;&#125;</code></pre><h1 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h1><ul><li>高亮语法：==Highlight==ing （==）</li><li>加粗：<strong>Bold</strong> （**）</li><li>斜体：<em>Wall</em>（*）</li><li>删除线：<del>请给我打钱</del>（~~）</li></ul><h1 id="音频及视频"><a href="#音频及视频" class="headerlink" title="音频及视频"></a>音频及视频</h1><p>暂不支持。。。</p><p>（正在努力开发中。。。）</p><pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>video</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>test/DSC_7412.MOV<span class="token punctuation">'</span></span>        <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>video/mp4<span class="token punctuation">'</span></span>        <span class="token attr-name">controls</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>controls<span class="token punctuation">'</span></span>         <span class="token attr-name">preload</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>auto<span class="token punctuation">"</span></span>       <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>100%<span class="token punctuation">'</span></span>        <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>100%<span class="token punctuation">'</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>video</span><span class="token punctuation">></span></span></code></pre><script type="math/tex; mode=display">END</script>]]></content>
      
      
      <categories>
          
          <category> Hexo搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
